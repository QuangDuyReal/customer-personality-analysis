cat("\n**Kiểm tra giá trị bị thiếu trong dữ liệu ngân hàng:**\n")
na_counts_bank <- colSums(is.na(bank_df))
if (any(na_counts_bank > 0)) {
cat("Phát hiện giá trị bị thiếu:\n")
kable(as.data.frame(na_counts_bank[na_counts_bank > 0]), col.names = c("Số lượng NA")) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)
cat("\nCẢNH BÁO: Dữ liệu có NA. Cần có chiến lược xử lý.\n")
rows_before_na_y <- nrow(bank_df)
bank_df <- bank_df[!is.na(bank_df$y), ]
if(nrow(bank_df) < rows_before_na_y){
cat(paste("Đã loại bỏ", rows_before_na_y - nrow(bank_df), "hàng có NA trong cột 'y'.\n"))
}
} else {
cat("Không tìm thấy giá trị bị thiếu trong dữ liệu ngân hàng.\n")
}
# Chuyển các cột character thành factor nếu chúng chưa phải
character_cols <- names(bank_df)[sapply(bank_df, is.character)]
if(length(character_cols) > 0) {
cat("\n**Chuyển đổi các cột character sang factor:**\n", paste(character_cols, collapse=", "), "\n")
for(col in character_cols){
bank_df[[col]] <- as.factor(bank_df[[col]])
}
cat("Hoàn tất chuyển đổi.\n")
}
set.seed(42) # Để kết quả có thể lặp lại
if (nrow(bank_df) == 0 || is.null(bank_df$y) || all(is.na(bank_df$y))) {
stop("Dữ liệu bank_df không hợp lệ hoặc biến y bị thiếu/rỗng.")
}
if (length(unique(bank_df$y)) < 2) {
stop("Biến y không có đủ số lượng lớp (>1) cho bài toán phân loại.")
}
trainIndexBank <- createDataPartition(bank_df$y, p = 0.7, list = FALSE, times = 1)
bank_train <- bank_df[trainIndexBank, ]
bank_test  <- bank_df[-trainIndexBank, ]
# Tách X và y
X_train <- bank_train[, !(names(bank_train) %in% "y")]
y_train <- bank_train$y
X_test <- bank_test[, !(names(bank_test) %in% "y")]
y_test <- bank_test$y
cat(paste0("Số lượng mẫu trong tập huấn luyện (X_train, y_train): ", nrow(X_train), "\n"))
cat(paste0("Số lượng mẫu trong tập kiểm tra (X_test, y_test): ", nrow(X_test), "\n"))
set.seed(42)
# Xây dựng mô hình Decision Tree sử dụng rpart
# cp (complexity parameter): giá trị nhỏ hơn -> cây phức tạp hơn.
# minsplit: số lượng observation tối thiểu trong một node để có thể chia tiếp.
dt_model_rpart <- rpart(
y ~ .,
data = bank_train,
method = "class",
control = rpart.control(cp = 0.005, minsplit = 20)
)
cat("\n**Tóm tắt mô hình Decision Tree (rpart):**\n")
printcp(dt_model_rpart)
set.seed(42)
train_control_bank_dt <- trainControl(
method = "cv",
number = 5, # 5-fold CV
summaryFunction = twoClassSummary,
classProbs = TRUE,
verboseIter = FALSE
)
cp_grid <- expand.grid(cp = c(0.001, 0.002, 0.005, 0.01, 0.02))
cat("\nĐang huấn luyện Decision Tree với caret (có thể mất một chút thời gian)...\n")
preproc_method_bank <- NULL
if(any(sapply(X_train, function(x) any(is.na(x))))) {
preproc_method_bank <- c("medianImpute") # Hoặc "knnImpute" cho số, mode cho factor (cần tùy chỉnh)
cat("Sẽ sử dụng median imputation cho các giá trị thiếu trong features của tập huấn luyện.\n")
}
dt_model_caret <- NULL
tryCatch({
dt_model_caret <- train(
x = X_train,
y = y_train,
method = "rpart", # Sử dụng thuật toán rpart (Decision Tree)
trControl = train_control_bank_dt,
tuneGrid = cp_grid,
metric = "ROC", # Tối ưu hóa theo AUC ROC
na.action = na.rpart, # Cách rpart xử lý NA (có thể là na.omit hoặc các cách khác)
preProcess = preproc_method_bank # Áp dụng imputation nếu cần
)
cat("Hoàn tất huấn luyện Decision Tree với caret.\n")
cat("\n**Kết quả huấn luyện mô hình Decision Tree (caret):**\n")
print(dt_model_caret)
cat("\n**Giá trị cp tốt nhất:**\n")
print(dt_model_caret$bestTune)
}, error = function(e){
cat("LỖI khi huấn luyện Decision Tree với caret:", e$message, "\n")
print(e)
})
best_dt_model <- if(!is.null(dt_model_caret)) dt_model_caret else dt_model_rpart
if (!is.null(best_dt_model)) {
if (inherits(best_dt_model, "train")) {
dt_predictions <- predict(best_dt_model, newdata = X_test)
dt_pred_probs <- predict(best_dt_model, newdata = X_test, type = "prob")
} else if (inherits(best_dt_model, "rpart")) {
# Nếu là từ rpart trực tiếp
dt_predictions <- predict(best_dt_model, newdata = X_test, type = "class")
dt_pred_probs <- predict(best_dt_model, newdata = X_test, type = "prob")
} else {
cat("Không nhận diện được loại mô hình để dự đoán.\n")
dt_predictions <- NULL
}
if (!is.null(dt_predictions)) {
cat("\n**Một vài dự đoán đầu tiên trên tập kiểm tra:**\n")
print(head(dt_predictions))
}
} else {
cat("Mô hình Decision Tree chưa được huấn luyện thành công.\n")
dt_predictions <- NULL
}
model_dt_evaluated_successfully <- FALSE
if (!is.null(dt_predictions) && !is.null(y_test) && length(dt_predictions) == length(y_test)) {
if (!is.factor(dt_predictions)) {
dt_predictions <- factor(dt_predictions, levels = levels(y_test))
} else {
common_levels <- intersect(levels(dt_predictions), levels(y_test))
if (length(common_levels) < 2) { # Cần ít nhất 2 level chung
cat("CẢNH BÁO: Levels không khớp hoặc không đủ giữa dự đoán và thực tế.\n")
cat("Levels dự đoán:", paste(levels(dt_predictions), collapse=", "), "\n")
cat("Levels thực tế:", paste(levels(y_test), collapse=", "), "\n")
} else {
dt_predictions <- factor(dt_predictions, levels = common_levels)
y_test_eval <- factor(y_test, levels = common_levels)
cat("\n**Ma trận nhầm lẫn (Confusion Matrix):**\n")
dt_conf_matrix <- confusionMatrix(data = dt_predictions, reference = y_test_eval, positive = "Yes_Subscription")
print(dt_conf_matrix)
cat("\n**Độ chính xác (Accuracy):** ", round(dt_conf_matrix$overall["Accuracy"] * 100, 2), "%\n")
cat("**Độ nhạy (Sensitivity/Recall for Yes_Subscription):** ", round(dt_conf_matrix$byClass["Sensitivity"] * 100, 2), "%\n")
cat("**Độ đặc hiệu (Specificity for Yes_Subscription):** ", round(dt_conf_matrix$byClass["Specificity"] * 100, 2), "%\n")
cat("**Giá trị F1 (F1-Score for Yes_Subscription):** ", round(dt_conf_matrix$byClass["F1"] * 100, 2), "%\n")
if ("ROC" %in% names(dt_conf_matrix$overall) && !is.na(dt_conf_matrix$overall["ROC"])) {
cat("**AUC ROC:** ", round(dt_conf_matrix$overall["ROC"], 4), "\n")
} else if (exists("dt_pred_probs") && !is.null(dt_pred_probs)) {
# Tính ROC AUC nếu confusionMatrix không tự tính (ví dụ khi dùng summaryFunction khác)
roc_auc_val <- MLmetrics::AUC(y_pred = dt_pred_probs$Yes_Subscription, y_true = ifelse(y_test_eval == "Yes_Subscription", 1, 0))
cat("**AUC ROC (tính riêng):** ", round(roc_auc_val, 4), "\n")
}
model_dt_evaluated_successfully <- TRUE
}
}
} else {
cat("Không thể đánh giá mô hình do dự đoán hoặc y_test không hợp lệ.\n")
}
if (!is.null(best_dt_model)) {
# Lấy mô hình rpart cuối cùng
final_rpart_model <- NULL
if (inherits(best_dt_model, "train") && !is.null(best_dt_model$finalModel)) {
final_rpart_model <- best_dt_model$finalModel
} else if (inherits(best_dt_model, "rpart")) {
final_rpart_model <- best_dt_model
}
if (!is.null(final_rpart_model)) {
cat("\n**Trực quan hóa Cây Quyết Định:**\n") # Output này có thể không cần thiết nếu bạn chỉ muốn đồ thị
# Thử giảm lề trước khi vẽ
par(mar = c(1, 1, 1, 1) + 0.1) # Giảm lề: dưới, trái, trên, phải
rpart.plot(final_rpart_model,
type = 2,
extra = "auto",
under = TRUE,
cex = 0.6, # Có thể giảm cex nếu cây quá lớn
box.palette = "GnBu",
branch.lty = 1,
shadow.col = "gray",
nn = TRUE,
compress = TRUE, # Thử nén cây lại
roundint = FALSE # Không làm tròn số nguyên trong node (giảm chiều rộng nhãn)
)
title(main = "Cây Quyết Định Dự Đoán Đăng Ký Tiền Gửi", cex.main = 0.9)
# Khôi phục lại lề mặc định nếu cần cho các đồ thị sau (không bắt buộc trong RMD chunk riêng)
# par(mar = c(5.1, 4.1, 4.1, 2.1))
} else {
cat("Không có mô hình rpart cuối cùng để trực quan hóa.\n")
}
} else {
cat("Không thể trực quan hóa vì mô hình chưa được huấn luyện.\n")
}
if (!is.null(best_dt_model)) {
# Lấy mô hình rpart cuối cùng
final_rpart_model <- NULL
if (inherits(best_dt_model, "train") && !is.null(best_dt_model$finalModel)) {
final_rpart_model <- best_dt_model$finalModel
} else if (inherits(best_dt_model, "rpart")) {
final_rpart_model <- best_dt_model
}
if (!is.null(final_rpart_model)) {
cat("\n**Trực quan hóa Cây Quyết Định:**\n") # Output này có thể không cần thiết nếu bạn chỉ muốn đồ thị
# Thử giảm lề trước khi vẽ
par(mar = c(1, 1, 1, 1) + 0.1) # Giảm lề: dưới, trái, trên, phải
rpart.plot(final_rpart_model,
type = 2,
extra = "auto",
under = TRUE,
cex = 0.6, # Có thể giảm cex nếu cây quá lớn
box.palette = "GnBu",
branch.lty = 1,
shadow.col = "gray",
nn = TRUE,
compress = TRUE, # Thử nén cây lại
roundint = FALSE # Không làm tròn số nguyên trong node (giảm chiều rộng nhãn)
)
title(main = "Cây Quyết Định Dự Đoán Đăng Ký Tiền Gửi", cex.main = 0.9)
# Khôi phục lại lề mặc định nếu cần cho các đồ thị sau (không bắt buộc trong RMD chunk riêng)
# par(mar = c(5.1, 4.1, 4.1, 2.1))
} else {
cat("Không có mô hình rpart cuối cùng để trực quan hóa.\n")
}
} else {
cat("Không thể trực quan hóa vì mô hình chưa được huấn luyện.\n")
}
if (model_dt_evaluated_successfully && !is.null(best_dt_model)) {
# Quyết định xem mô hình có "phù hợp" không dựa trên các metrics
# Ví dụ, nếu Accuracy > 75% và AUC > 0.7
accuracy_threshold <- 0.75
auc_threshold <- 0.70
current_accuracy <- if (!is.null(dt_conf_matrix)) dt_conf_matrix$overall["Accuracy"] else 0
current_auc <- 0
if(!is.null(dt_conf_matrix) && "ROC" %in% names(dt_conf_matrix$overall) && !is.na(dt_conf_matrix$overall["ROC"])) {
current_auc <- dt_conf_matrix$overall["ROC"]
} else if (exists("roc_auc_val")) {
current_auc <- roc_auc_val
}
if (current_accuracy >= accuracy_threshold && current_auc >= auc_threshold) {
cat("\nMô hình được xem là phù hợp. Đang lưu mô hình...\n")
# saveRDS(best_dt_model, file = "decision_tree_bank_model.rds")
cat("Mô hình đã được lưu vào file 'decision_tree_bank_model.rds' (đã comment lệnh save thực tế).\n")
} else {
cat("\nMô hình chưa đạt ngưỡng phù hợp để lưu tự động.\n")
cat(paste("Accuracy hiện tại:", round(current_accuracy * 100, 2), "% (ngưỡng:", accuracy_threshold * 100, "%)\n"))
cat(paste("AUC hiện tại:", round(current_auc, 4), "(ngưỡng:", auc_threshold, ")\n"))
}
} else {
cat("\nKhông thể đánh giá hoặc mô hình không được huấn luyện, nên không lưu mô hình.\n")
}
# Chuẩn bị dữ liệu cho ggplot
# Lấy dữ liệu train ở thang đo gốc
df_train_actual <- data.frame(
Time = time(champagne_ts_original_scale_train),
Value = as.numeric(champagne_ts_original_scale_train),
Type = "Train"
)
# Lấy dữ liệu test (thực tế) ở thang đo gốc
df_test_actual <- data.frame(
Time = time(champagne_ts_original_scale_test),
Value = as.numeric(champagne_ts_original_scale_test),
Type = "Test (Actual)"
)
# Lấy dữ liệu dự đoán trên tập test ở thang đo gốc
df_test_predict <- data.frame(
Time = time(forecast_test_original_scale_mean), # Sử dụng time từ forecast object
Value = as.numeric(forecast_test_original_scale_mean),
Type = "Predict (on Test)"
)
# Lấy dữ liệu dự đoán 9 tháng tiếp theo ở thang đo gốc
df_next_9_months_predict <- data.frame(
Time = time(forecast_next_9_months_original_scale_mean),
Value = as.numeric(forecast_next_9_months_original_scale_mean),
Type = "Next 9 Months"
)
# Kết hợp tất cả lại
combined_df <- bind_rows(df_train_actual, df_test_actual, df_test_predict, df_next_9_months_predict)
# Vẽ đồ thị với ggplot2
ggplot(combined_df, aes(x = Time, y = Value, color = Type, linetype = Type)) +
geom_line(size = 0.8) +
scale_color_manual(values = c("Train" = "steelblue",
"Test (Actual)" = "darkorange",
"Predict (on Test)" = "forestgreen",
"Next 9 Months" = "firebrick")) +
scale_linetype_manual(values = c("Train" = "solid",
"Test (Actual)" = "solid",
"Predict (on Test)" = "dashed",
"Next 9 Months" = "solid")) +
labs(title = "Dự đoán Doanh số Champagne",
subtitle = "Bao gồm Dữ liệu Train, Test thực tế, Dự đoán trên Test, và Dự đoán 9 tháng tới",
x = "Thời gian (Năm)",
y = "Doanh số (triệu)",
color = "Loại dữ liệu",
linetype = "Loại dữ liệu") +
theme_minimal() +
theme(legend.position = "top",
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5, size=9))
library(factoextra)
library(cluster)
library(ggplot2)
library(patchwork)
# (Đảm bảo customers_scaled đã được tạo và chuẩn hóa ở Phần 5.2.2)
# Phương pháp Elbow
set.seed(123)
p_elbow <- fviz_nbclust(customers_scaled, kmeans, method = "wss") +
geom_vline(xintercept = 4, linetype = 2, color="steelblue") + # Giả sử chọn k=4
labs(title = "Phương pháp Elbow", subtitle = "Tổng bình phương sai số trong cụm (WCSS)") +
theme_minimal()
# Phương pháp Silhouette
set.seed(123)
p_silhouette <- fviz_nbclust(customers_scaled, kmeans, method = "silhouette") +
labs(title = "Phương pháp Silhouette", subtitle = "Silhouette trung bình") +
theme_minimal()
# Hiển thị 2 biểu đồ (bạn cần chạy code thực tế để có biểu đồ)
p_elbow + p_silhouette
library(factoextra)
library(cluster)
library(ggplot2)
library(patchwork)
# (Đảm bảo customers_scaled đã được tạo và chuẩn hóa ở Phần 5.2.2)
# Phương pháp Elbow
set.seed(123)
p_elbow <- fviz_nbclust(customers_scaled, kmeans, method = "wss") +
geom_vline(xintercept = 4, linetype = 2, color="steelblue") + # Giả sử chọn k=4
labs(title = "Phương pháp Elbow", subtitle = "Tổng bình phương sai số trong cụm (WCSS)") +
theme_minimal()
# Phương pháp Silhouette
set.seed(123)
p_silhouette <- fviz_nbclust(customers_scaled, kmeans, method = "silhouette") +
labs(title = "Phương pháp Silhouette", subtitle = "Silhouette trung bình") +
theme_minimal()
# Hiển thị 2 biểu đồ (bạn cần chạy code thực tế để có biểu đồ)
p_elbow + p_silhouette
library(factoextra)
library(cluster)
library(ggplot2)
library(patchwork)
# (Đảm bảo customers_scaled đã được tạo và chuẩn hóa ở Phần 5.2.2)
# Phương pháp Elbow
set.seed(123)
p_elbow <- fviz_nbclust(customers_scaled, kmeans, method = "wss") +
geom_vline(xintercept = 4, linetype = 2, color="steelblue") + # Giả sử chọn k=4
labs(title = "Phương pháp Elbow", subtitle = "Tổng bình phương sai số trong cụm (WCSS)") +
theme_minimal()
# Phương pháp Silhouette
set.seed(123)
p_silhouette <- fviz_nbclust(customers_scaled, kmeans, method = "silhouette") +
labs(title = "Phương pháp Silhouette", subtitle = "Silhouette trung bình") +
theme_minimal()
# Hiển thị 2 biểu đồ (bạn cần chạy code thực tế để có biểu đồ)
p_elbow + p_silhouette
# (Đảm bảo customers_scaled và kmeans_result đã có)
fviz_cluster(kmeans_result, data = customers_scaled,
ellipse.type = "confidence", # Hoặc "convex", "euclid"
geom = "point",
pointsize = 1,
ggtheme = theme_minimal(),
main = paste("Phân cụm K-Means (k=", optimal_k, ") với PCA"))
library(dplyr)
# Tính toán giá trị trung bình của các biến số lượng theo từng cụm
cluster_summary_numerical <- customers_final %>%
group_by(Cluster_KMeans) %>%
summarise(
Avg_Income = mean(Income, na.rm = TRUE),
Avg_Age = mean(Age, na.rm = TRUE),
Avg_Total_Spent = mean(total_spent, na.rm = TRUE), # Sử dụng total_spent gốc để dễ diễn giải
Avg_Recency = mean(Recency, na.rm = TRUE),
Avg_Child_Total = mean(Child_Total, na.rm = TRUE),
Avg_Days_Customer = mean(Days_Customer, na.rm = TRUE),
Avg_NumDealsPurchases = mean(NumDealsPurchases, na.rm = TRUE),
Avg_AcceptedCmp_Total = mean(AcceptedCmp_Total, na.rm = TRUE),
Avg_NumWebVisitsMonth = mean(NumWebVisitsMonth, na.rm = TRUE),
Count = n() # Số lượng khách hàng trong mỗi cụm
) %>%
arrange(Cluster_KMeans)
# Hiển thị bảng tóm tắt (sử dụng kable hoặc pander để đẹp hơn nếu muốn)
knitr::kable(cluster_summary_numerical, caption = "Giá trị trung bình của các biến số lượng theo cụm K-Means")
print(cluster_summary_numerical)
library(dplyr)
# Tính toán giá trị trung bình của các biến số lượng theo từng cụm
cluster_summary_numerical <- customers_final %>%
group_by(Cluster_KMeans) %>%
summarise(
Avg_Income = mean(Income, na.rm = TRUE),
Avg_Age = mean(Age, na.rm = TRUE),
Avg_Total_Spent = mean(total_spent, na.rm = TRUE), # Sử dụng total_spent gốc để dễ diễn giải
Avg_Recency = mean(Recency, na.rm = TRUE),
Avg_Child_Total = mean(Child_Total, na.rm = TRUE),
Avg_Days_Customer = mean(Days_Customer, na.rm = TRUE),
Avg_NumDealsPurchases = mean(NumDealsPurchases, na.rm = TRUE),
Avg_AcceptedCmp_Total = mean(AcceptedCmp_Total, na.rm = TRUE),
Avg_NumWebVisitsMonth = mean(NumWebVisitsMonth, na.rm = TRUE),
Count = n() # Số lượng khách hàng trong mỗi cụm
) %>%
arrange(Cluster_KMeans)
# Hiển thị bảng tóm tắt (sử dụng kable hoặc pander để đẹp hơn nếu muốn)
knitr::kable(cluster_summary_numerical, caption = "Giá trị trung bình của các biến số lượng theo cụm K-Means")
print(cluster_summary_numerical)
# Ví dụ boxplot cho một vài biến
p_income_cluster <- ggplot(customers_final, aes(x = Cluster_KMeans, y = Income, fill = Cluster_KMeans)) + geom_boxplot() + theme_minimal() + ggtitle("Thu nhập theo Cụm")
p_spent_cluster <- ggplot(customers_final, aes(x = Cluster_KMeans, y = total_spent, fill = Cluster_KMeans)) + geom_boxplot() + theme_minimal() + ggtitle("Tổng chi tiêu theo Cụm")
p_child_cluster <- ggplot(customers_final, aes(x = Cluster_KMeans, y = Child_Total, fill = Cluster_KMeans)) + geom_boxplot() + theme_minimal() + ggtitle("Số con theo Cụm")
p_recency_cluster <- ggplot(customers_final, aes(x = Cluster_KMeans, y = Recency, fill = Cluster_KMeans)) + geom_boxplot() + theme_minimal() + ggtitle("Recency theo Cụm")
(p_income_cluster | p_spent_cluster) / (p_child_cluster | p_recency_cluster)
# Ví dụ boxplot cho một vài biến
p_income_cluster <- ggplot(customers_final, aes(x = Cluster_KMeans, y = Income, fill = Cluster_KMeans)) + geom_boxplot() + theme_minimal() + ggtitle("Thu nhập theo Cụm")
p_spent_cluster <- ggplot(customers_final, aes(x = Cluster_KMeans, y = total_spent, fill = Cluster_KMeans)) + geom_boxplot() + theme_minimal() + ggtitle("Tổng chi tiêu theo Cụm")
p_child_cluster <- ggplot(customers_final, aes(x = Cluster_KMeans, y = Child_Total, fill = Cluster_KMeans)) + geom_boxplot() + theme_minimal() + ggtitle("Số con theo Cụm")
p_recency_cluster <- ggplot(customers_final, aes(x = Cluster_KMeans, y = Recency, fill = Cluster_KMeans)) + geom_boxplot() + theme_minimal() + ggtitle("Recency theo Cụm")
(p_income_cluster | p_spent_cluster) / (p_child_cluster | p_recency_cluster)
View(p_spent_cluster)
# (Đảm bảo logistic_model, test_set_log, probabilities, predicted_classes đã được tạo ở Mục 5.3.2)
# 1. Ma trận nhầm lẫn (Confusion Matrix) và các chỉ số liên quan
library(caret)
conf_matrix_log <- confusionMatrix(predicted_classes, test_set_log$Response, positive = "X1")
print(conf_matrix_log)
# 2. Đường cong ROC và giá trị AUC
library(pROC)
roc_curve_log <- roc(response = test_set_log$Response, predictor = probabilities, levels = c("X0", "X1"), direction = "<") # Đảm bảo levels đúng
plot(roc_curve_log, main = "Đường cong ROC cho Hồi quy Logistic", print.auc = TRUE)
auc_value_log <- auc(roc_curve_log)
print(paste("Giá trị AUC:", round(auc_value_log, 4)))
# # Thay thế bằng hình ảnh đã chạy:
# knitr::include_graphics("path_to_your_confusion_matrix_logistic.png") # Ảnh chụp ma trận nhầm lẫn
# knitr::include_graphics("path_to_your_roc_curve_logistic.png") # Ảnh đường cong ROC
# (Đảm bảo logistic_model đã được tạo ở Mục 5.3.2)
summary_logistic_model <- summary(logistic_model)
print(summary_logistic_model$coefficients)
# Tính toán Odds Ratios
odds_ratios <- exp(coef(logistic_model))
print(data.frame(Variable = names(odds_ratios), Odds_Ratio = odds_ratios))
# Nạp thư viện cần thiết
library("caret")
library("pROC") # Để vẽ ROC và tính AUC
# Chọn các biến độc lập và biến mục tiêu 'Response'
# Loại bỏ các biến liên quan đến chi tiêu đã tính log và gốc
cols_for_logistic <- setdiff(names(customers_final), c("log_total_spent", "total_spent"))
logistic_data <- customers_final[, cols_for_logistic]
# Chuyển Response thành factor với levels phù hợp (quan trọng cho caret và confusion matrix)
logistic_data$Response <- as.factor(make.names(logistic_data$Response)) # Tạo level X0 và X1
set.seed(123) # Để có thể tái lập kết quả chia
trainIndex <- createDataPartition(logistic_data$Response, p = .75,
list = FALSE,
times = 1)
train_set_log <- logistic_data[ trainIndex,]
test_set_log  <- logistic_data[-trainIndex,]
# Kiểm tra tỷ lệ Response trong 2 tập (đảm bảo stratified)
prop.table(table(train_set_log$Response))
prop.table(table(test_set_log$Response))
# Sử dụng công thức '.' để bao gồm tất cả các predictors còn lại
logistic_model <- glm(Response ~ ., data = train_set_log, family = binomial(link = "logit"))
# Xem tóm tắt mô hình để diễn giải hệ số
summary(logistic_model)
# (Tùy chọn) Kiểm tra đa cộng tuyến
library(car)
vif(logistic_model)
# Dự đoán xác suất P(Response=1) (tức là P(Response=X1))
probabilities <- predict(logistic_model, newdata = test_set_log, type = "response")
# Chuyển đổi xác suất thành lớp dự đoán (0 hoặc 1) dùng ngưỡng 0.5
predicted_classes <- ifelse(probabilities > 0.5, "X1", "X0")
predicted_classes <- as.factor(predicted_classes)
# Ví dụ tạo confusion matrix:
confusionMatrix(predicted_classes, test_set_log$Response, positive = "X1")
# Ví dụ tính AUC và vẽ ROC:
roc_curve <- roc(response = test_set_log$Response, predictor = probabilities)
plot(roc_curve, main = "ROC Curve for Logistic Regression")
auc(roc_curve)
# Chọn các biến độc lập và biến mục tiêu 'Response'
# Loại bỏ các biến liên quan đến chi tiêu đã tính log và gốc
cols_for_logistic <- setdiff(names(customers_final), c("log_total_spent", "total_spent"))
logistic_data <- customers_final[, cols_for_logistic]
# Chuyển Response thành factor với levels phù hợp (quan trọng cho caret và confusion matrix)
logistic_data$Response <- as.factor(make.names(logistic_data$Response)) # Tạo level X0 và X1
# Chọn các biến độc lập và biến mục tiêu 'log_total_spent' từ 'customers_final'
# Loại bỏ 'Response' và 'total_spent' gốc
cols_for_linear <- setdiff(names(customers_final), c("Response", "total_spent"))
linear_data <- customers_final[, cols_for_linear]
# (Ví dụ: tỷ lệ 75%/25%)
set.seed(456) # Sử dụng một seed khác hoặc seed cũ nếu muốn cùng các hàng mẫu
trainIndex_lm <- createDataPartition(linear_data$log_total_spent, p = .75,
list = FALSE,
times = 1)
train_set_lm <- linear_data[ trainIndex_lm,]
test_set_lm  <- linear_data[-trainIndex_lm,]
# Sử dụng công thức '.' để bao gồm tất cả các predictors trong train_set_lm
linear_model <- lm(log_total_spent ~ ., data = train_set_lm)
# Xem tóm tắt mô hình để diễn giải hệ số và R-squared
summary(linear_model)
# (Tùy chọn) Kiểm tra đa cộng tuyến trên mô hình này
library(car)
vif(linear_model)
predictions_lm <- predict(linear_model, newdata = test_set_lm)
# Ví dụ tính RMSE:
actual_values_lm <- test_set_lm$log_total_spent
rmse_lm <- sqrt(mean((actual_values_lm - predictions_lm)^2))
print(paste("RMSE for Linear Regression:", rmse_lm))
par(mfrow = c(2, 2))
plot(linear_model)
par(mfrow = c(1, 1)) # Reset layout
# (Đảm bảo linear_model, train_set_lm, test_set_lm, predictions_lm, actual_values_lm, rmse_lm đã được tạo ở Mục 5.4.2)
# 1. R-squared và Adjusted R-squared từ summary của mô hình huấn luyện
summary_linear_model <- summary(linear_model)
r_squared <- summary_linear_model$r.squared
adj_r_squared <- summary_linear_model$adj.r.squared
print(paste("R-squared trên tập huấn luyện:", round(r_squared, 4)))
print(paste("Adjusted R-squared trên tập huấn luyện:", round(adj_r_squared, 4)))
# 2. Tính R-squared trên tập kiểm tra (để đánh giá khả năng tổng quát hóa)
sst_lm_test <- sum((actual_values_lm - mean(actual_values_lm))^2)
sse_lm_test <- sum((actual_values_lm - predictions_lm)^2)
r_squared_test <- 1 - (sse_lm_test / sst_lm_test)
print(paste("R-squared trên tập kiểm tra:", round(r_squared_test, 4)))
# 3. RMSE trên tập kiểm tra
print(paste("RMSE trên tập kiểm tra (cho log_total_spent):", round(rmse_lm, 4)))
# Để diễn giải RMSE dễ hơn, có thể chuyển về thang đo gốc (nếu cần, nhưng thường RMSE của log-transformed là đủ)
original_scale_predictions_lm <- expm1(predictions_lm) # exp(x) - 1
original_scale_actual_lm <- expm1(actual_values_lm)
rmse_original_scale_lm <- sqrt(mean((original_scale_actual_lm - original_scale_predictions_lm)^2))
print(paste("RMSE trên tập kiểm tra (thang đo gốc của total_spent):", round(rmse_original_scale_lm, 2)))
# (Đảm bảo linear_model đã được tạo ở Mục 5.4.2)
par(mfrow = c(2, 2))
plot(linear_model)
par(mfrow = c(1, 1)) # Reset layout
# Thay thế bằng hình ảnh đã chạy:
#knitr::include_graphics("path_to_your_linear_model_diagnostic_plots.png")
# (Đảm bảo linear_model đã được tạo ở Mục 5.4.2)
summary_linear_model_coeffs <- summary(linear_model)$coefficients
knitr::kable(summary_linear_model_coeffs, caption = "Bảng hệ số Hồi quy Tuyến tính Đa biến")
print(summary_linear_model_coeffs)
